#! /usr/bin/env perl

# The minefield programming language
# Copyright 2018 Eric J. Deiman

# This file is part of the minefield programming language.

# The minefield programming language is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any later
# version.

# The minefield programming language is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with the
# minefield programming language. If not, see <https://www.gnu.org/licenses/>

use strict;

use POSIX;

scalar @ARGV == 2 or die "use: processByteCodes.pl ByteCodes.data ByteCodes.java.template";

# First, read the byte code data file and fill in the tables
my $fin;
my @opCodes;
my @hasOperands;
my @descriptions;

open( $fin, $ARGV[ 0 ] );
while( <$fin> ) {
    # Remove comments
    s/#.*$//;
    $_ = trim( $_ );
    if ( !length( $_ ) ){ next; }
    my @fields = split( /;/ );

    foreach my $f ( @fields ) {
        $f = trim( $f );
    }

    push( @opCodes, $fields[ 0 ] );
    push( @hasOperands, $fields[ 1 ] );
    push( @descriptions, $fields[ 2 ] );
}

close $fin;

my $longestOpCodeName = 0;

foreach my $o ( @opCodes ) {
    $longestOpCodeName = max( $longestOpCodeName, length( $o ) );
}

my $templateFileName = $ARGV[ 1 ];
my $outputFileName = $templateFileName;
$outputFileName =~ s/\.template//;

my $fout;

open( $fin, $templateFileName ) or die "cannot open $templateFileName\n";
open( $fout, ">$outputFileName" ) or die "cannot open $outputFileName\n";

printf $fout "// This file was generated by %s on %s\n\n", $0,
    (strftime "%F %T", localtime $^T );

# Then, fill in the template to generate the output file
while( <$fin> ) {
    printf $fout "%s",  $_;
    if( m/\/\/\*\* Begin Byte Code (.*)/ ) {
        if( trim( $1 ) eq "Names" ) {
            my $i = 0;
            foreach my $o ( @opCodes ) {
                printf $fout "\t\t\t\t%s,%s// 0x%0.2x\n", $o,
                    " " x ( $longestOpCodeName - length( $o ) + 1 ),
                    $i++;
            }            
        }
        elsif( trim( $1 ) eq "Operands" ) {
            foreach my $o ( @hasOperands ) {
                printf $fout "\t\t\t\t%s,\n", $o;
            }                        
        }
        elsif( trim( $1 ) eq "Descriptions" ) {
            foreach my $o ( @descriptions ) {
                printf $fout "\t\t\t\t\"%s\",\n", $o;
            }                        
        }
    }
}

# Remove leading and trailing spaces
sub trim {
    my $target = shift;
    $target =~ s/^\s+//;
    $target =~ s/\s+$//;

    return $target;
}

sub max {
    my $first = shift;
    my $second = shift;

    if( $first < $second ){ return $second; }
    return $first; 
}
